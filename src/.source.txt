; tl16c2550_asm.s
; Low-level assembly routines for TL16C2550 UART
; Optimized for 65C02 processor in Commander X16

;---------------------------------------------------------------------------
; Exported functions (available to C code)
;---------------------------------------------------------------------------

.export _scanUARTs         ; Scan for UART devices
.export _irq_handler_active ; Flag indicating if IRQ handler is installed

;---------------------------------------------------------------------------
; Imported variables (defined in C, used in assembly)
;---------------------------------------------------------------------------
.import _uart_instances     ; Array of UART_Instance pointers
.import _uart_instance_count ; Count of active UART instances
.importzp _sp
.include "zeropage.inc"
.include "tl16c2550.inc"
.include "cx16.inc"
.segment "CODE"

;---------------------------------------------------------------------------
; Scan for UART devices by testing scratch register
; uint8_t __fastcall__ scanUARTs(uint16_t *addresses);
; Input: AX = pointer to address buffer (A=low byte, X=high byte)
; Output: A = number of UARTs found
; Destroys: All registers
;---------------------------------------------------------------------------
.proc _scanUARTs
    sta ptr1            ; Store buffer pointer (low byte in ptr1)
    stx ptr1+1          ; Store buffer pointer (high byte in ptr1+1)
    
    lda #$00            ; Start address low byte (0x9F60 & 0xFF = 0x60)
    sta ptr2            ; Store in address working variable (zero page pointer)
    lda #$9F            ; Start address high byte
    sta ptr2+1          ; Store in address working variable (zero page pointer)
    
    lda #$00            ; Counter for found UARTs
    sta found_count     ; Initialize count
    
    lda #20             ; Loop 20 times (addresses from 9F60 to 9FF8)
    sta loop_count      ; Initialize loop counter
    
@scan_loop:
    ; Write test value to scratch register (offset 7)
    lda #$A5            ; Test pattern (10100101)
    ldy #7              ; Offset to scratch register
    sta (ptr2),y        ; Write test value to scratch register
    
    ; Read back and verify
    lda (ptr2),y        ; Read scratch register
    cmp #$A5            ; Compare with test pattern
    bne @skip_address   ; If not equal, skip this address
    
    ; Found a UART! Store the address
    lda found_count     ; Get current count
    asl                 ; Multiply by 2 for 16-bit address storage
    tay                 ; Use as index into buffer
    
    lda ptr2            ; Get low byte of address
    sta (ptr1),y        ; Store in buffer
    
    iny                 ; Move to next position
    lda ptr2+1          ; Get high byte of address
    sta (ptr1),y        ; Store in buffer
    
    inc found_count     ; Increment found count
    
@skip_address:
    ; Move to next address (add UART_OFFSET)
    lda ptr2
    clc
    adc UART_OFSETS    ; Add offset (0x08)
    sta ptr2
    
    dec loop_count      ; Decrement loop counter
    bne @scan_loop      ; Continue if more addresses to check
    
    lda found_count     ; Return the count of found UARTs
    rts
.endproc

;---------------------------------------------------------------------------
; Install custom IRQ handler
; Saves the current IRQ vector and installs our handler
; Input: None
; Output: None
; Destroys: A
;---------------------------------------------------------------------------
addIRQ:
    ; Save the current IRQ vector so we can chain to it later
    lda IRQ_VECTOR              ; Load low byte of current IRQ handler
    sta default_irq_vector      ; Store it for later
    lda IRQ_VECTOR+1            ; Load high byte of current IRQ handler
    sta default_irq_vector+1    ; Store it for later
    
    ; Install our custom IRQ handler
    sei                         ; Disable interrupts while modifying vector
    lda #<irqHandler            ; Load low byte of our handler address
    sta IRQ_VECTOR              ; Store it in the IRQ vector
    lda #>irqHandler            ; Load high byte of our handler address
    sta IRQ_VECTOR+1            ; Store it in the IRQ vector
    lda #1                      ; Set flag to indicate handler is active
    sta _irq_handler_active     ; Store the flag
    cli                         ; Re-enable interrupts
    rts

;---------------------------------------------------------------------------
; Restore original IRQ handler
; Restores the IRQ vector that was saved by addIRQ
; Input: None
; Output: None
; Destroys: A
;---------------------------------------------------------------------------
restoreIRQ:
    sei                         ; Disable interrupts while modifying vector
    lda default_irq_vector      ; Load low byte of saved IRQ handler
    sta IRQ_VECTOR              ; Restore it to the IRQ vector
    lda default_irq_vector+1    ; Load high byte of saved IRQ handler
    sta IRQ_VECTOR+1            ; Restore it to the IRQ vector
    stz _irq_handler_active     ; Clear flag (store zero) - handler not active
    cli                         ; Re-enable interrupts
    rts

;---------------------------------------------------------------------------
; Custom IRQ handler
; This is called when any hardware interrupt occurs
; Currently just chains to the original handler (placeholder)
; Note: Registers (A,X,Y) are already saved by KERNAL before we get here
;---------------------------------------------------------------------------
irqHandler:
    ; TODO: Check UART IIR registers to see if UART caused the interrupt
    ; TODO: If UART interrupt, handle it (read/write data to buffers)
    ; Chain to the original IRQ handler to process other interrupt sources
    jmp (default_irq_vector)


;---------------------------------------------------------------------------
; Working variables for UART scanning
;---------------------------------------------------------------------------
.segment "DATA"
found_count: .byte 0            ; Count of UARTs found
loop_count: .byte 0             ; Loop counter
default_irq_vector: .word 0     ; Storage for the default IRQ vector
_irq_handler_active: .byte 0    ; Flag: 1 if IRQ handler is active, 0 if not

